// FIXED server.js - Proper handling of database and in-memory modes

const express = require('express');
const cors = require('cors');
const path = require('path');
const { OpenAI } = require('openai');
const Anthropic = require('@anthropic-ai/sdk');
const fetch = require('node-fetch');
const mysql = require('mysql2/promise');
const { AuthService, authenticateToken, checkTokenBalance } = require('./authMiddleware');

require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.static(path.join(__dirname, 'public')));

// Initialize authentication service
const authService = new AuthService();

// Initialize AI clients
const clients = {
    openai: process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null,
    anthropic: process.env.ANTHROPIC_API_KEY ? new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY }) : null,
    deepseek: process.env.DEEPSEEK_API_KEY ? { apiKey: process.env.DEEPSEEK_API_KEY } : null,
};

// Deepseek chat helper
async function callDeepseekChat(model, message, history) {
    const url = 'https://api.deepseek.com/chat/completions';
    const headers = {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${clients.deepseek.apiKey}`,
    };
    const body = JSON.stringify({
        model,
        messages: [...history.slice(-10), { role: 'user', content: message }],
    });

    const response = await fetch(url, { method: 'POST', headers, body });
    if (!response.ok) {
        const error = await response.text();
        throw new Error(`Deepseek API error: ${error}`);
    }

    const data = await response.json();
    return data.choices?.[0]?.message?.content || 'Deepseek response unavailable';
}

// Available models
const AVAILABLE_MODELS = {
    openai: {
        'gpt-4': 'GPT-4',
        'gpt-4-turbo': 'GPT-4 Turbo',
        'gpt-3.5-turbo': 'GPT-3.5 Turbo',
    },
    anthropic: {
        'claude-3-5-sonnet-20241022': 'Claude-3.5 Sonnet',
        'claude-3-haiku-20240307': 'Claude-3 Haiku',
        'claude-3-sonnet-20240229': 'Claude-3 Sonnet',
    },
    deepseek: {
        'deepseek-chat': 'Deepseek Chat',
        'deepseek-coder': 'Deepseek Coder',
    },
};

// Language codes
const SUPPORTED_LANGUAGES = {
    'en': 'English', 'es': 'Spanish', 'fr': 'French', 'de': 'German',
    'it': 'Italian', 'pt': 'Portuguese', 'ru': 'Russian', 'ja': 'Japanese',
    'ko': 'Korean', 'zh': 'Chinese (Simplified)', 'zh-tw': 'Chinese (Traditional)',
    'ar': 'Arabic', 'hi': 'Hindi', 'nl': 'Dutch', 'sv': 'Swedish',
    'da': 'Danish', 'no': 'Norwegian', 'fi': 'Finnish', 'pl': 'Polish',
    'tr': 'Turkish', 'th': 'Thai', 'vi': 'Vietnamese', 'id': 'Indonesian',
    'ms': 'Malay', 'tl': 'Filipino', 'he': 'Hebrew', 'fa': 'Persian',
    'ur': 'Urdu', 'bn': 'Bengali', 'gu': 'Gujarati', 'ta': 'Tamil',
    'te': 'Telugu', 'kn': 'Kannada', 'ml': 'Malayalam', 'mr': 'Marathi', 'pa': 'Punjabi',
};

function isProviderAvailable(provider) {
    return clients[provider] !== null;
}

function estimateTokens(text) {
    return Math.ceil(text.length / 4);
}

function calculateCost(tokens, model = 'gpt-3.5-turbo') {
    const costPerToken = {
        'gpt-4': 0.00003,
        'gpt-4-turbo': 0.00001,
        'gpt-3.5-turbo': 0.000002,
        'claude-3-5-sonnet-20241022': 0.000015,
        'claude-3-haiku-20240307': 0.00000025,
        'claude-3-sonnet-20240229': 0.000003,
        'deepseek-chat': 0.0000014,
        'deepseek-coder': 0.0000014,
    };
    return tokens * (costPerToken[model] || 0.000002);
}

// ===== AUTHENTICATION ROUTES =====

app.post('/api/auth/register', async (req, res) => {
    try {
        const { email, password, firstName, lastName, categories = [] } = req.body;
        if (!email || !password) {
            return res.status(400).json({ error: 'Email and password are required' });
        }
        if (password.length < 8) {
            return res.status(400).json({ error: 'Password must be at least 8 characters long' });
        }

        const result = await authService.registerUser(email, password, firstName, lastName);
        res.status(201).json(result);
    } catch (error) {
        console.error('Registration error:', error);
        res.status(400).json({ error: error.message || 'Registration failed' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        if (!email || !password) {
            return res.status(400).json({ error: 'Email and password are required' });
        }

        const result = await authService.loginUser(email, password);
        res.json(result);
    } catch (error) {
        console.error('Login error:', error);
        res.status(401).json({ error: error.message || 'Login failed' });
    }
});

app.post('/api/auth/logout', authenticateToken, async (req, res) => {
    try {
        console.log(`User ${req.user.user_id} logged out at ${new Date().toISOString()}`);
        res.json({ message: 'Logged out successfully' });
    } catch (error) {
        console.error('Logout error:', error);
        res.status(500).json({ error: 'Logout failed' });
    }
});

app.get('/api/auth/profile', authenticateToken, async (req, res) => {
    try {
        const user = await authService.getUserById(req.user.user_id);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.json(user);
    } catch (error) {
        console.error('Profile fetch error:', error);
        res.status(500).json({ error: 'Failed to fetch profile' });
    }
});

app.put('/api/auth/profile', authenticateToken, async (req, res) => {
    try {
        const result = await authService.updateUserProfile(req.user.user_id, { ...req.body, email: req.user.email });
        res.json(result);
    } catch (error) {
        console.error('Profile update error:', error);
        res.status(500).json({ error: error.message || 'Failed to update profile' });
    }
});

app.get('/api/user-categories', async (req, res) => {
    try {
        const categories = await authService.getUserCategories();
        res.json(categories);
    } catch (error) {
        console.error('Categories fetch error:', error);
        res.status(500).json({ error: 'Failed to fetch categories' });
    }
});

app.post('/api/auth/forgot-password', async (req, res) => {
    try {
        const { email } = req.body;
        if (!email) {
            return res.status(400).json({ error: 'Email is required' });
        }

        const result = await authService.generatePasswordResetToken(email);
        res.json({ message: 'Password reset token generated', token: result.resetToken });
    } catch (error) {
        console.error('Forgot password error:', error);
        res.status(500).json({ error: error.message || 'Failed to generate reset token' });
    }
});

app.post('/api/auth/reset-password', async (req, res) => {
    try {
        const { token, password } = req.body;
        if (!token || !password) {
            return res.status(400).json({ error: 'Token and password are required' });
        }
        if (password.length < 8) {
            return res.status(400).json({ error: 'Password must be at least 8 characters long' });
        }

        const result = await authService.resetPassword(token, password);
        res.json(result);
    } catch (error) {
        console.error('Password reset error:', error);
        res.status(400).json({ error: error.message || 'Password reset failed' });
    }
});

// ===== DASHBOARD COUNT ENDPOINTS (FIXED) =====

app.get('/api/content/prebuilt/count', authenticateToken, async (req, res) => {
    try {
        const count = await authService.getPrebuiltContentCount();
        res.json({ count });
    } catch (error) {
        console.error('Prebuilt count error:', error);
        res.json({ count: 0 });
    }
});

app.get('/api/content/bookmarks/count', authenticateToken, async (req, res) => {
    try {
        const count = await authService.getUserBookmarksCount(req.user.user_id);
        res.json({ count });
    } catch (error) {
        console.error('Bookmark count error:', error);
        res.json({ count: 0 });
    }
});

app.get('/api/content/custom/count', authenticateToken, async (req, res) => {
    try {
        const count = await authService.getUserContentCount(req.user.user_id);
        res.json({ count });
    } catch (error) {
        console.error('Custom count error:', error);
        res.json({ count: 0 });
    }
});

app.get('/api/transformations/count', authenticateToken, async (req, res) => {
    try {
        const count = await authService.getUserTransformationsCount(req.user.user_id);
        res.json({ count });
    } catch (error) {
        console.error('Transformations count error:', error);
        res.json({ count: 0 });
    }
});

// ===== EXISTING ROUTES =====

app.get('/api/health', async (req, res) => {
    const health = {};
    for (const provider of Object.keys(clients)) {
        try {
            health[provider] = !!clients[provider];
        } catch (e) {
            health[provider] = false;
        }
    }
    res.json(health);
});

app.get('/api/models', (req, res) => {
    const models = {};
    Object.entries(AVAILABLE_MODELS).forEach(([provider, modelsList]) => {
        if (isProviderAvailable(provider)) {
            models[provider] = modelsList;
        }
    });
    res.json(models);
});

app.get('/api/languages', (req, res) => {
    res.json(SUPPORTED_LANGUAGES);
});

app.post('/api/chat', authenticateToken, checkTokenBalance(10), async (req, res) => {
    const { provider, model, message, history = [] } = req.body;
    
    if (!provider || !model || !message) {
        return res.status(400).json({ error: 'Missing required parameters' });
    }
    if (!isProviderAvailable(provider)) {
        return res.status(400).json({ error: `Provider ${provider} is not available` });
    }
    if (!AVAILABLE_MODELS[provider]?.[model]) {
        return res.status(400).json({ error: `Model ${model} not available for ${provider}` });
    }

    try {
        let responseText = '';
        const startTime = Date.now();

        if (provider === 'openai') {
            const completion = await clients.openai.chat.completions.create({
                model,
                messages: [...history.slice(-10), { role: 'user', content: message }],
                temperature: 0.7,
                max_tokens: 4000,
            });
            responseText = completion.choices[0].message.content;
        } else if (provider === 'anthropic') {
            const completion = await clients.anthropic.messages.create({
                model,
                max_tokens: 4000,
                temperature: 0.7,
                messages: [...history.slice(-10).filter(m => m.role !== 'system'), { role: 'user', content: message }],
            });
            responseText = completion.content[0].text;
        } else if (provider === 'deepseek') {
            responseText = await callDeepseekChat(model, message, history);
        } else {
            throw new Error(`Unsupported provider: ${provider}`);
        }

        const executionTime = Date.now() - startTime;
        const tokensUsed = estimateTokens(message + responseText);
        const cost = calculateCost(tokensUsed, model);

        await authService.updateTokenUsage(req.user.user_id, tokensUsed, cost);

        // Save to content history if available
        if (authService.memory) {
            authService.memory.content_history.push({
                content_id: authService.memory.content_history.length + 1,
                user_id: req.user.user_id,
                content_type: 'chat',
                title: message.substring(0, 100),
                content: responseText,
                prompt_used: message,
                llm_model: `${provider}/${model}`,
                tokens_used: tokensUsed,
                cost: cost,
                created_at: new Date().toISOString()
            });
        }

        res.json({
            response: responseText,
            provider,
            model,
            tokensUsed,
            cost: parseFloat(cost.toFixed(6)),
            executionTime,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error(`Chat error for ${provider}/${model}:`, error);
        res.status(500).json({ error: error.message || 'An error occurred' });
    }
});

app.post('/api/translate', authenticateToken, checkTokenBalance(5), async (req, res) => {
    const { provider, model, text, sourceLang, targetLang } = req.body;
    
    if (!provider || !model || !text || !targetLang) {
        return res.status(400).json({ error: 'Missing required parameters' });
    }
    if (!isProviderAvailable(provider)) {
        return res.status(400).json({ error: `Provider ${provider} is not available` });
    }
    if (!AVAILABLE_MODELS[provider]?.[model]) {
        return res.status(400).json({ error: `Model ${model} not available for ${provider}` });
    }

    const sourceLanguage = SUPPORTED_LANGUAGES[sourceLang] || 'auto-detect';
    const targetLanguage = SUPPORTED_LANGUAGES[targetLang] || targetLang;
    const translationPrompt = sourceLang === 'auto'
        ? `Translate the following text to ${targetLanguage}. Only provide the translation, no explanations:\n\n"${text}"`
        : `Translate the following text from ${sourceLanguage} to ${targetLanguage}. Only provide the translation, no explanations:\n\n"${text}"`;

    try {
        let translatedText = '';
        const startTime = Date.now();

        if (provider === 'openai') {
            const completion = await clients.openai.chat.completions.create({
                model,
                messages: [{ role: 'user', content: translationPrompt }],
                temperature: 0.3,
                max_tokens: 2000,
            });
            translatedText = completion.choices[0].message.content.trim();
        } else if (provider === 'anthropic') {
            const completion = await clients.anthropic.messages.create({
                model,
                max_tokens: 2000,
                temperature: 0.3,
                messages: [{ role: 'user', content: translationPrompt }],
            });
            translatedText = completion.content[0].text.trim();
        } else if (provider === 'deepseek') {
            translatedText = await callDeepseekChat(model, translationPrompt, []);
        } else {
            throw new Error(`Unsupported provider: ${provider}`);
        }

        translatedText = translatedText.replace(/^["']|["']$/g, '');
        const executionTime = Date.now() - startTime;
        const tokensUsed = estimateTokens(text + translatedText);
        const cost = calculateCost(tokensUsed, model);

        await authService.updateTokenUsage(req.user.user_id, tokensUsed, cost);

        res.json({
            translatedText,
            sourceLang: sourceLang === 'auto' ? 'auto-detected' : sourceLang,
            targetLang,
            provider,
            model,
            tokensUsed,
            cost: parseFloat(cost.toFixed(6)),
            executionTime,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error(`Translation error for ${provider}/${model}:`, error);
        res.status(500).json({ error: error.message || 'Translation failed' });
    }
});

app.post('/api/detect-language', authenticateToken, async (req, res) => {
    const { provider, model, text } = req.body;
    
    if (!provider || !model || !text) {
        return res.status(400).json({ error: 'Missing required parameters' });
    }
    if (!isProviderAvailable(provider)) {
        return res.status(400).json({ error: `Provider ${provider} is not available` });
    }

    const detectionPrompt = `Detect the language of the following text and respond with only the language name in English (e.g., "English", "Spanish", "French", etc.):\n\n"${text}"`;

    try {
        let detectedLanguage = '';
        
        if (provider === 'openai') {
            const completion = await clients.openai.chat.completions.create({
                model,
                messages: [{ role: 'user', content: detectionPrompt }],
                temperature: 0.1,
                max_tokens: 50,
            });
            detectedLanguage = completion.choices[0].message.content.trim();
        } else if (provider === 'anthropic') {
            const completion = await clients.anthropic.messages.create({
                model,
                max_tokens: 50,
                temperature: 0.1,
                messages: [{ role: 'user', content: detectionPrompt }],
            });
            detectedLanguage = completion.content[0].text.trim();
        } else if (provider === 'deepseek') {
            detectedLanguage = await callDeepseekChat(model, detectionPrompt, []);
        }

        const langCode = Object.keys(SUPPORTED_LANGUAGES).find(
            code => SUPPORTED_LANGUAGES[code].toLowerCase() === detectedLanguage.toLowerCase()
        );

        res.json({
            detectedLanguage,
            languageCode: langCode || 'unknown',
            provider,
            model,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error(`Language detection error for ${provider}/${model}:`, error);
        res.status(500).json({ error: error.message || 'Language detection failed' });
    }
});

// Content history endpoint
app.get('/api/content/history', authenticateToken, async (req, res) => {
    try {
        const contents = await authService.getUserContentHistory(req.user.user_id, 50);
        res.json(contents);
    } catch (error) {
        console.error('Content history error:', error);
        res.status(500).json({ error: 'Failed to fetch content history' });
    }
});

// Serve static pages
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/login', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'login.html'));
});

app.get('/dashboard', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'dashboard.html'));
});

app.get('/translate', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'translate.html'));
});

app.get('/profile-setup', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'profile-setup.html'));
});

app.get('/workspace', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'workspace.html'));
});

// Error handling
app.use((err, req, res, next) => {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error' });
});

app.use((req, res) => {
    res.status(404).json({ error: 'Route not found' });
});

app.listen(PORT, () => {
    console.log(`🚀 Multi-LLM Platform server running on port ${PORT}`);
    console.log(`📍 Access the application at: http://localhost:${PORT}`);
});

module.exports = app;