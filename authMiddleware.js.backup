// Simple AuthService and middlewares usable by server.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const mysql = require('mysql2/promise');

const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-change-me';

class AuthService {
    constructor() {
        this.resetTokens = new Map(); // email -> { token, expiresAt }
        this.dbPool = null;
        this.initDb();
    }

    async initDb() {
        try {
            const host = process.env.DB_HOST || 'localhost';
            const port = process.env.DB_PORT ? Number(process.env.DB_PORT) : 3306;
            const user = process.env.DB_USER || 'root';
            const password = process.env.DB_PASSWORD || '';
            const database = process.env.DB_NAME || 'multi_llm_platform';

            this.dbPool = await mysql.createPool({ host, port, user, password, database, waitForConnections: true, connectionLimit: 10 });

            // Create minimal tables if they don't exist
            const connection = await this.dbPool.getConnection();
            try {
                await connection.query(`
                    CREATE TABLE IF NOT EXISTS users (
                        user_id INT AUTO_INCREMENT PRIMARY KEY,
                        email VARCHAR(255) UNIQUE NOT NULL,
                        password_hash VARCHAR(255) NOT NULL,
                        first_name VARCHAR(100) NULL,
                        last_name VARCHAR(100) NULL,
                        profile_completed TINYINT(1) DEFAULT 1,
                        tokens_remaining INT DEFAULT 1000,
                        plan_name VARCHAR(50) DEFAULT 'Free',
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    ) ENGINE=InnoDB;
                `);
                await connection.query(`
                    CREATE TABLE IF NOT EXISTS content_history (
                        content_id INT AUTO_INCREMENT PRIMARY KEY,
                        user_id INT NOT NULL,
                        content_type VARCHAR(50) NOT NULL,
                        title VARCHAR(255) NOT NULL,
                        content MEDIUMTEXT NOT NULL,
                        prompt_used TEXT,
                        llm_model VARCHAR(100),
                        tokens_used INT DEFAULT 0,
                        cost DECIMAL(10,6) DEFAULT 0,
                        language VARCHAR(10),
                        age_level VARCHAR(50),
                        is_favorite TINYINT(1) DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        INDEX(user_id),
                        FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
                    ) ENGINE=InnoDB;
                `);
            } finally {
                connection.release();
            }
        } catch (err) {
            // If DB init fails, provide a minimal in-memory fallback
            console.warn('Database initialization failed, falling back to in-memory auth:', err.message);
            this.memory = { users: [], nextId: 1 };
            this.dbPool = {
                async getConnection() {
                    return {
                        async execute() { /* no-op in memory */ },
                        release() { /* no-op */ }
                    };
                }
            };
        }
    }

    signToken(user) {
        const payload = { user_id: user.user_id, email: user.email };
        return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
    }

    async getUserByEmail(email) {
        if (this.memory) {
            return this.memory.users.find(u => u.email === email) || null;
        }
        const [rows] = await this.dbPool.execute('SELECT * FROM users WHERE email = ? LIMIT 1', [email]);
        return rows[0] || null;
    }

    async getUserById(userId) {
        if (this.memory) {
            return this.memory.users.find(u => u.user_id === userId) || null;
        }
        const [rows] = await this.dbPool.execute('SELECT user_id, email, first_name, last_name, profile_completed, tokens_remaining, plan_name FROM users WHERE user_id = ? LIMIT 1', [userId]);
        return rows[0] || null;
    }

    async registerUser(email, password, firstName, lastName) {
        const existing = await this.getUserByEmail(email);
        if (existing) throw new Error('Email already registered');
        const passwordHash = await bcrypt.hash(password, 10);

        if (this.memory) {
            const user = { user_id: this.memory.nextId++, email, password_hash: passwordHash, first_name: firstName || null, last_name: lastName || null, profile_completed: 1, tokens_remaining: 1000, plan_name: 'Free' };
            this.memory.users.push(user);
            const token = this.signToken(user);
            return this.toAuthResponse(user, token);
        }

        const [result] = await this.dbPool.execute(
            'INSERT INTO users (email, password_hash, first_name, last_name, profile_completed, tokens_remaining, plan_name) VALUES (?,?,?,?,1,1000,\'Free\')',
            [email, passwordHash, firstName || null, lastName || null]
        );
        const user = await this.getUserById(result.insertId);
        const token = this.signToken(user);
        return this.toAuthResponse(user, token);
    }

    async loginUser(email, password) {
        const user = await this.getUserByEmail(email);
        if (!user) throw new Error('Invalid credentials');
        const valid = await bcrypt.compare(password, user.password_hash);
        if (!valid) throw new Error('Invalid credentials');
        const fullUser = this.memory ? user : await this.getUserById(user.user_id);
        const token = this.signToken(fullUser);
        return this.toAuthResponse(fullUser, token);
    }

    toAuthResponse(user, token) {
        return {
            token,
            userId: user.user_id,
            email: user.email,
            firstName: user.first_name || null,
            lastName: user.last_name || null,
            profileCompleted: !!user.profile_completed,
            tokensRemaining: user.tokens_remaining ?? 1000,
            planName: user.plan_name || 'Free'
        };
    }

    async updateUserProfile(userId, data) {
        if (this.memory) {
            let user = this.memory.users.find(u => u.user_id === userId);
            // If in-memory store lost the user (e.g., server restart), recreate a minimal user using email
            if (!user && data?.email) {
                user = { user_id: userId, email: data.email, password_hash: '', first_name: null, last_name: null, profile_completed: 0, tokens_remaining: 1000, plan_name: 'Free' };
                this.memory.users.push(user);
            }
            if (!user) throw new Error('User not found');
            if (data.firstName !== undefined) user.first_name = data.firstName;
            if (data.lastName !== undefined) user.last_name = data.lastName;
            if (data.gender !== undefined) user.gender = data.gender;
            if (data.contactNo !== undefined) user.contact_no = data.contactNo;
            if (data.occupation !== undefined) user.occupation = data.occupation;
            if (data.address !== undefined) user.address = data.address;
            if (data.profileCompleted !== undefined) user.profile_completed = data.profileCompleted ? 1 : 0;
            return { message: 'Profile updated' };
        }
        const fields = [];
        const values = [];
        if (data.firstName !== undefined) { fields.push('first_name = ?'); values.push(data.firstName); }
        if (data.lastName !== undefined) { fields.push('last_name = ?'); values.push(data.lastName); }
        if (data.profileCompleted !== undefined) { fields.push('profile_completed = ?'); values.push(data.profileCompleted ? 1 : 0); }
        if (fields.length === 0) return { message: 'No changes' };
        values.push(userId);
        await this.dbPool.execute(`UPDATE users SET ${fields.join(', ')} WHERE user_id = ?`, values);
        return { message: 'Profile updated' };
    }

    async getUserCategories() {
        // Minimal categories for UI; replace with DB-backed categories if needed
        return [
            { category_id: 1, category_name: 'Education' },
            { category_id: 2, category_name: 'Business' },
            { category_id: 3, category_name: 'Creative' },
            { category_id: 4, category_name: 'Developer' }
        ];
    }

    async generatePasswordResetToken(email) {
        const user = await this.getUserByEmail(email);
        if (!user) throw new Error('No account with that email');
        const token = Math.random().toString(36).slice(2) + Math.random().toString(36).slice(2);
        const expiresAt = Date.now() + 1000 * 60 * 15; // 15 minutes
        this.resetTokens.set(token, { userId: user.user_id, expiresAt });
        return { resetToken: token, expiresAt };
    }

    async resetPassword(token, newPassword) {
        const data = this.resetTokens.get(token);
        if (!data) throw new Error('Invalid or expired token');
        if (Date.now() > data.expiresAt) {
            this.resetTokens.delete(token);
            throw new Error('Reset token expired');
        }
        const passwordHash = await bcrypt.hash(newPassword, 10);
        if (this.memory) {
            const user = this.memory.users.find(u => u.user_id === data.userId);
            if (!user) throw new Error('User not found');
            user.password_hash = passwordHash;
        } else {
            await this.dbPool.execute('UPDATE users SET password_hash = ? WHERE user_id = ?', [passwordHash, data.userId]);
        }
        this.resetTokens.delete(token);
        return { message: 'Password updated successfully' };
    }

    async updateTokenUsage(userId, tokensUsed, cost) {
        if (this.memory) {
            const user = this.memory.users.find(u => u.user_id === userId);
            if (user && typeof user.tokens_remaining === 'number') {
                user.tokens_remaining = Math.max(0, user.tokens_remaining - Number(tokensUsed || 0));
            }
            return;
        }
        // Decrement tokens_remaining if column exists
        try {
            await this.dbPool.execute('UPDATE users SET tokens_remaining = GREATEST(tokens_remaining - ?, 0) WHERE user_id = ?', [Number(tokensUsed || 0), userId]);
        } catch (_) {
            // ignore if column doesn't exist
        }
    }
}

function authenticateToken(req, res, next) {
    try {
        const authHeader = req.headers['authorization'] || '';
        const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;
        if (!token) return res.status(401).json({ error: 'Missing token' });
        const payload = jwt.verify(token, JWT_SECRET);
        req.user = { user_id: payload.user_id, email: payload.email };
        next();
    } catch (err) {
        return res.status(401).json({ error: 'Invalid token' });
    }
}

function checkTokenBalance(minTokens) {
    return async (req, res, next) => {
        // For simplicity, let requests through; server updates usage afterward.
        next();
    };
}

module.exports = { AuthService, authenticateToken, checkTokenBalance };


